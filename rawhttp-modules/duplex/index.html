<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer">
    
    <meta name="description" content="RawHTTP - a HTTP library for the JVM">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:domain" content="https://renatoathaydes.github.io/rawhttp">
    
    <meta name="twitter:image" content="https://renatoathaydes.github.io/rawhttp/tn.png">
    <meta name="twitter:title" property="og:title" itemprop="title name" content="RawHTTP">
    <meta name="twitter:description" property="og:description" itemprop="description" content="RawHTTP - a HTTP library for the JVM">
    <meta name="og:type" content="website">
    <meta name="og:url" content="https://renatoathaydes.github.io/rawhttp">
    <meta name="og:image" itemprop="image primaryImageOfPage" content="https://renatoathaydes.github.io/rawhttp/tn.png">
    
    <title>RawHTTP</title>
    <link rel="shortcut icon" href="https://renatoathaydes.github.io/rawhttp/sam.ico" id="favicon">
    <link rel="stylesheet" href="https://renatoathaydes.github.io/rawhttp/css/style.css">
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic">
    
    <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous"></script>
    
    

</head>

</html>
<body><div class="wrap"><div class="section" id="title">RawHTTP Duplex</div><div class="section" id="content">

<p>The rawhttp-duplex module can be used to create a duplex communication channel as either a client or a server.</p>

<p>The entry point of the library is the <code>com.athaydes.rawhttp.duplex.RawHttpDuplex</code> class.</p>

<p>Its <code>connect</code> methods are used from a client to connect to a server,
while the <code>accept</code> methods should be used within a HTTP server to handle requests from a client.</p>

<p>Example Kotlin code on the server:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">import</span> rawhttp.core.*
<span style="color:#66d9ef">import</span> com.athaydes.rawhttp.duplex.*
<span style="color:#66d9ef">import</span> rawhttp.core.server.TcpRawHttpServer;

<span style="color:#66d9ef">val</span> http = RawHttp()
<span style="color:#66d9ef">val</span> duplex = RawHttpDuplex()
<span style="color:#66d9ef">val</span> server = TcpRawHttpServer(<span style="color:#ae81ff">8082</span>)

server.start { request -&gt;
    <span style="color:#75715e">// TODO check the request is a POST to the /connect path!
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// call duplex.accept() to return a response that can initiate duplex communication
</span><span style="color:#75715e"></span>    Optional.of(duplex.accept(request, { sender -&gt;
        <span style="color:#66d9ef">object</span> <span style="color:#960050;background-color:#1e0010">: </span><span style="color:#a6e22e">MessageHandler</span> {
            <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">onTextMessage</span>(message: String) {
                <span style="color:#75715e">// handle text message 
</span><span style="color:#75715e"></span>                sender.sendTextMessage(<span style="color:#e6db74">&#34;Hi there! You sent this: $message&#34;</span>)
            }      
            <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">onBinaryMessage</span>(message: ByteArray, headers: RawHttpHeaders) { <span style="color:#75715e">/* handle binary message */</span> }
            <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">onClose</span>() { <span style="color:#75715e">/* handle closed connection */</span> }
        }
    }))
}</code></pre></div>

<hr/>

<p>Example Kotlin code on the client:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-kotlin" data-lang="kotlin"><span style="color:#66d9ef">import</span> rawhttp.core.*
<span style="color:#66d9ef">import</span> com.athaydes.rawhttp.duplex.*
<span style="color:#66d9ef">import</span> rawhttp.core.server.TcpRawHttpServer;

<span style="color:#66d9ef">val</span> http = RawHttp()
<span style="color:#66d9ef">val</span> duplex = RawHttpDuplex()

duplex.connect(http.parseRequest(<span style="color:#e6db74">&#34;POST http://localhost:8082/connect&#34;</span>), { sender -&gt;
    <span style="color:#66d9ef">object</span> <span style="color:#960050;background-color:#1e0010">: </span><span style="color:#a6e22e">MessageHandler</span> { <span style="color:#75715e">/* same API as on the server */</span> }
}</code></pre></div>

<h2 id="how-duplex-works">How duplex works</h2>

<p>The way duplex communication is achieved uses only HTTP/1.1 standard mechanisms and can be described as follows:</p>

<ul>
<li>The server listens for requests to start duplex communication.</li>
<li>When a client connects, the server sends out a single chunked response in which each chunk
is a new message from the server to the client.</li>
<li>The client does the same: it sends a chunked body with the request in which each chunk is a message from the
client to the server.</li>
</ul>

<p>In other words, a single request/response is used to bootstrap communications. Both the request and the response
have effectively infinite chunked bodies where each chunk represents a message.</p>

<p><code>RawHttpDuplex</code> sends a single extension parameter to idenfity text
messages: <code>Content-Type: text/plain</code> (notice that each chunk may contain &ldquo;extensions&rdquo;).</p>

<p>If the chunk does not contain this extension, then it is considered to be a binary message.</p>

<p>Text messages may also contain the <code>Charset: &lt;charset&gt;</code> (e.g. <code>Charset: US-ASCII</code>) extension parameter to provide a
charset for the message. By default, <code>UTF-8</code> is used.</p>

<p>Each side of a connection pings the other every 5 seconds, by default, to avoid the TCP socket timing out.
To use a different ping period, use the {@link RawHttpDuplex#RawHttpDuplex(TcpRawHttpClient, Duration)} constructor.</p>

<h2 id="demo">Demo</h2>

<p>As is mandatory for duplex communication implementations,
a <a href="https://github.com/renatoathaydes/rawhttp/blob/master/rawhttp-duplex/src/test/kotlin/chat-example.kt">Chat Demo application</a>
was written in Kotlin to demonstrate usage of this library.</p>

<p>The video below shows it in action:</p>

<iframe width="600" height="400" alt="rawhttp-duplex chat app in action"
 src="https://www.youtube.com/embed/_h3a5yodVgM"></iframe>
</div><div class="section bottom-menu"><hr/><p><a href="/rawhttp/in-5-minutes">RawHTTP in 5 minutes</a>


&#183; <a href="/rawhttp/docs">Documentation</a>
&#183; <a href="/rawhttp/rawhttp-modules">Modules</a>
&#183; <a href="/rawhttp/about">About</a>

&#183; <a href="https://renatoathaydes.github.io/rawhttp"></a></p></div><div class="section footer">RawHTTP - a HTTP library for the JVM</div></div></body>